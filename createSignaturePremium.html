
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/signature_pad@4.1.7/dist/signature_pad.umd.min.js"></script>
<style>
    /* Custom styling for the canvas border and shadow */
    #signatureCanvasContainer {
        border: 2px solid #e5e7eb; /* light gray */
        border-radius: 0.5rem;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        touch-action: none; /* Prevent scrolling/zooming on the canvas on touch devices */
        /* IMPORTANT FIX: Hide the native cursor (no more +) and rely only on the overlay */
        cursor: none; 
        position: relative; /* Needed for absolute positioning of overlay */
    }
    
    /* Overlay Canvas for the visual cursor indicator */
    #cursorOverlay {
        position: absolute;
        top: 0;
        left: 0;
        /* Ensure mouse events pass through to the drawing canvas */
        pointer-events: none; 
    }
</style>
<script>
    // Configuration for Tailwind CSS (using Inter font as requested)
    tailwind.config = {
        theme: {
            extend: {
                fontFamily: {
                    sans: ['Inter', 'sans-serif'],
                },
            },
        },
    };
</script>

<body class="bg-gray-50 min-h-screen flex items-start justify-center p-4 sm:p-8 font-sans">

    <div class="w-full max-w-4xl bg-white rounded-xl shadow-2xl p-6 sm:p-8 my-8">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-6 border-b pb-3 flex items-center">
            <svg class="w-7 h-7 mr-2 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
            </svg>
            Digital Signature Pad
        </h1>

        <div id="signatureCanvasContainer" class="mb-6 relative aspect-[2/1]">
            <!-- The main canvas is now transparent by default -->
            <canvas id="signatureCanvas" class="w-full h-full bg-white"></canvas>
            <canvas id="cursorOverlay" class="w-full h-full"></canvas>
        </div>

        <div class="mb-6 flex flex-col lg:flex-row gap-4 justify-between items-center p-4 bg-gray-100 rounded-lg">
            
            <div class="flex items-center space-x-4">
                <label for="penColor" class="text-sm font-medium text-gray-700 whitespace-nowrap">Pen Color:</label>
                <input type="color" id="penColor" value="#000000" class="w-10 h-10 p-1 border-gray-300 rounded-full cursor-pointer transition duration-150 ease-in-out hover:ring-2 hover:ring-indigo-500">
            </div>

            <div class="flex items-center space-x-3 w-full lg:w-1/3">
                <label for="penThickness" class="text-sm font-medium text-gray-700 whitespace-nowrap">Thickness (<span id="thicknessValue" class="inline-block w-8 text-center">2.0</span>):</label>
                <input type="range" id="penThickness" min="0.5" max="10" step="0.5" value="2.0" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer range-lg">
            </div>

            <button id="toggleErase" class="flex items-center px-4 py-2 bg-yellow-500 text-white font-semibold rounded-lg shadow-md transition duration-150 ease-in-out hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2 w-full lg:w-auto">
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 14l9-5-9-5-9 5 9 5z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 14L12 21"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 19H5a2 2 0 01-2-2V7a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2z"></path></svg>
                <span id="eraseButtonText">Start Erasing</span>
            </button>
        </div>

        <div class="grid grid-cols-2 md:grid-cols-4 gap-3 mb-6 items-start">
            
            <button id="clear" class="flex items-center justify-center px-2 py-3 bg-red-500 text-white font-semibold rounded-lg shadow-md transition duration-150 ease-in-out hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50" disabled>
                <svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                Clear
            </button>
            
            <button id="undo" class="flex items-center justify-center px-2 py-3 bg-gray-500 text-white font-semibold rounded-lg shadow-md transition duration-150 ease-in-out hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 disabled:opacity-50" disabled>
                <svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                Undo
            </button>
            
            <button id="redo" class="flex items-center justify-center px-2 py-3 bg-gray-500 text-white font-semibold rounded-lg shadow-md transition duration-150 ease-in-out hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 disabled:opacity-50" disabled>
                <svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0018 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.433 5.341 6 7.234 6 9.5a6.002 6.002 0 004 5.659v2.585l-1.405 1.405z"></path></svg>
                Redo
            </button>
            
            <div class="relative inline-block text-left w-full">
                <button id="exportDropdownButton" class="flex items-center justify-center w-full px-2 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md transition duration-150 ease-in-out hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50" disabled>
                    <svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                    Export
                    <svg class="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </button>

                <div id="exportDropdownMenu" class="origin-top-right absolute right-0 mt-2 w-64 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 hidden z-10">
                    <div class="py-1" role="menu" aria-orientation="vertical" aria-labelledby="exportDropdownButton">
                        <a href="#" id="exportPngOpaque" class="flex items-center justify-between px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">
                            <span>PNG</span> 
                            <span class="text-xs text-gray-500"> (White Background)</span>
                        </a>
                        <a href="#" id="exportPngTransparent" class="flex items-center justify-between px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">
                            <span>PNG</span>
                            <span class="text-xs text-gray-500"> (Transparent)</span>
                        </a>
                        <a href="#" id="exportJpeg" class="flex items-center justify-between px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">
                            <span>JPEG</span>
                            <span class="text-xs text-gray-500"> (Lossy)</span>
                        </a>
                        <a href="#" id="exportSvg" class="flex items-center justify-between px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">
                            <span>SVG</span>
                            <span class="text-xs text-gray-500"> (Vector)</span>
                        </a>
                    </div>
                </div>
            </div>
        </div>

        <div id="messageBox" class="p-3 bg-green-100 text-green-800 rounded-lg hidden transition-opacity duration-300 opacity-0"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('signatureCanvas');
            const overlayCanvas = document.getElementById('cursorOverlay');
            const penColorInput = document.getElementById('penColor');
            const penThicknessInput = document.getElementById('penThickness');
            const thicknessValueSpan = document.getElementById('thicknessValue');
            const toggleEraseButton = document.getElementById('toggleErase');
            const clearButton = document.getElementById('clear');
            const undoButton = document.getElementById('undo');
            const redoButton = document.getElementById('redo');
            const messageBox = document.getElementById('messageBox');
            
            // Export Dropdown elements
            const exportDropdownButton = document.getElementById('exportDropdownButton');
            const exportDropdownMenu = document.getElementById('exportDropdownMenu');
            
            let signaturePad = null;
            let overlayCtx = null;
            let history = []; 
            let historyPointer = -1;
            let isErasing = false;
            let currentPenColor = '#000000';
            let currentPenWidth = parseFloat(penThicknessInput.value); 
            
            // --- CONSTANTS ---
            // Set the primary canvas background to fully transparent
            const BACKGROUND_COLOR = 'rgba(0,0,0,0)'; 
            // Unique color used to identify eraser strokes in history data
            const ERASER_INTERNAL_COLOR = '#FFFFFE'; 
            const RATIO = Math.max(1, window.devicePixelRatio || 1);
            // Factor to visually scale the cursor overlay size
            const cursorScaleFactor = 2; 
            
            // --- 1. Initialization and Resizing ---

            function resizeCanvas() {
                const ratio = RATIO; 
                const data = signaturePad ? signaturePad.toData() : null;

                // Set drawing canvas size (scaled)
                canvas.width = canvas.offsetWidth * ratio;
                canvas.height = canvas.offsetHeight * ratio;
                canvas.getContext('2d').scale(ratio, ratio);

                // Set overlay canvas size (scaled)
                overlayCanvas.width = canvas.width;
                overlayCanvas.height = canvas.offsetHeight * ratio; 
                overlayCanvas.getContext('2d').scale(ratio, ratio);
                overlayCtx = overlayCanvas.getContext('2d');


                // Restore signature after resize
                if (data) {
                    signaturePad.clear(); // Clears with transparent background
                    signaturePad.fromData(data);
                }
            }

            function initSignaturePad() {
                signaturePad = new SignaturePad(canvas, {
                    backgroundColor: BACKGROUND_COLOR, // Initial transparent background
                    penColor: currentPenColor,
                    minWidth: currentPenWidth * 0.9,
                    maxWidth: currentPenWidth * 1.1,
                    throttle: 16
                });

                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                signaturePad.addEventListener("endStroke", () => {
                    // Only save history if the user actually drew something new.
                    if (signaturePad.toData().length > (historyPointer >= 0 ? history[historyPointer].length : 0)) {
                         saveHistory();
                    }
                    updateButtons();
                });
            }

            // --- 2. History Management ---

            function saveHistory() {
                history = history.slice(0, historyPointer + 1);
                // Deep copy the data to avoid issues with direct object references
                const data = signaturePad.toData().map(group => ({ ...group, points: [...group.points] }));
                history.push(data);
                historyPointer = history.length - 1;
            }

            function loadState(index) {
                if (index >= -1 && index < history.length) {
                    historyPointer = index;
                    signaturePad.clear();
                    if (historyPointer >= 0) {
                        signaturePad.fromData(history[historyPointer]);
                    }
                }
            }

            function undo() {
                if (historyPointer > 0) {
                    loadState(historyPointer - 1);
                } else if (historyPointer === 0) {
                    // Load the empty state (historyPointer = -1)
                    loadState(-1);
                }
                updateButtons();
            }

            function redo() {
                if (historyPointer < history.length - 1) {
                    loadState(historyPointer + 1);
                }
                updateButtons();
            }

            // --- 3. Cursor Overlay (Visual feedback) ---
            
            let isDrawing = false;
            canvas.addEventListener('mousedown', () => { 
                isDrawing = true; 
                clearCursorOverlay(); 
            });
            canvas.addEventListener('mouseup', () => { 
                isDrawing = false; 
            });
            canvas.addEventListener('mouseout', clearCursorOverlay);

            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing) { 
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left; 
                    const y = e.clientY - rect.top;
                    drawCursorOverlay(x, y);
                }
            });

            function clearCursorOverlay() {
                if (overlayCtx) {
                    overlayCtx.clearRect(0, 0, overlayCanvas.width / RATIO, overlayCanvas.height / RATIO);
                }
            }

            function drawCursorOverlay(x, y) {
                if (!overlayCtx) return;

                overlayCtx.clearRect(0, 0, overlayCanvas.width / RATIO, overlayCanvas.height / RATIO);

                // Uses the current pen width and the scaling factor (1.2)
                const radius = (currentPenWidth * cursorScaleFactor) / 2; 

                overlayCtx.beginPath();
                overlayCtx.arc(x, y, radius, 0, 2 * Math.PI);

                if (isErasing) {
                    // Eraser visual feedback
                    overlayCtx.strokeStyle = 'rgba(0, 0, 0, 0.7)'; 
                    overlayCtx.lineWidth = 1;
                    overlayCtx.setLineDash([3, 3]);
                    overlayCtx.fillStyle = 'rgba(255, 255, 255, 0.3)'; 
                    overlayCtx.fill();
                    overlayCtx.stroke();
                } else {
                    // Pen visual feedback
                    overlayCtx.setLineDash([]); 
                    overlayCtx.fillStyle = `${currentPenColor}4D`; // 30% Opacity
                    overlayCtx.fill();
                }
                overlayCtx.closePath();
            }


            // --- 4. UI State and Controls ---

            function updateButtons() {
                const hasContent = !signaturePad.isEmpty();
                const canUndo = historyPointer > -1;
                const canRedo = historyPointer < history.length - 1;

                clearButton.disabled = !hasContent;
                undoButton.disabled = !canUndo;
                redoButton.disabled = !canRedo;
                exportDropdownButton.disabled = !hasContent;
                
                if (!hasContent) {
                    exportDropdownMenu.classList.add('hidden');
                }

                // Update erase button text and color
                const eraseButtonTextSpan = toggleEraseButton.querySelector('span');
                if (isErasing) {
                    toggleEraseButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-500');
                    toggleEraseButton.classList.add('bg-gray-700', 'hover:bg-gray-800', 'focus:ring-gray-700');
                    eraseButtonTextSpan.textContent = 'Stop Erasing (Active)';
                } else {
                    toggleEraseButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-500');
                    toggleEraseButton.classList.remove('bg-gray-700', 'hover:bg-gray-800', 'focus:ring-gray-700');
                    eraseButtonTextSpan.textContent = 'Start Erasing';
                }
            }
            
            penColorInput.addEventListener('input', (e) => {
                currentPenColor = e.target.value;
                if (!isErasing) {
                    signaturePad.penColor = currentPenColor;
                }
            });

            penThicknessInput.addEventListener('input', (e) => {
                currentPenWidth = parseFloat(e.target.value);
                thicknessValueSpan.textContent = currentPenWidth.toFixed(1); 
                
                signaturePad.minWidth = currentPenWidth * 0.9;
                signaturePad.maxWidth = currentPenWidth * 1.1;
                
                // Show cursor at center for immediate size feedback
                if (!isDrawing && overlayCtx) {
                    const rect = canvas.getBoundingClientRect();
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    
                    drawCursorOverlay(centerX, centerY);
                    setTimeout(clearCursorOverlay, 500); 
                }
            });

            toggleEraseButton.addEventListener('click', () => {
                isErasing = !isErasing;

                if (isErasing) {
                    // Set composite mode to clear and set pen color to a unique, detectable ID
                    signaturePad.globalCompositeOperation = 'destination-out';
                    signaturePad.penColor = ERASER_INTERNAL_COLOR; // Unique ID for eraser strokes
                    penColorInput.disabled = true;
                    showTemporaryMessage('Erase Mode Active.', 'bg-yellow-100 text-yellow-800');
                } else {
                    // Reset to drawing mode
                    signaturePad.globalCompositeOperation = 'source-over'; 
                    signaturePad.penColor = currentPenColor; 
                    penColorInput.disabled = false;
                    showTemporaryMessage('Drawing Mode Active.', 'bg-green-100 text-green-800');
                }
                updateButtons();
            });

            // --- 5. Action Handlers (Export) ---
            
            clearButton.addEventListener('click', () => {
                signaturePad.clear();
                history = [];
                historyPointer = -1;
                updateButtons();
                showTemporaryMessage('Signature cleared.', 'bg-red-100 text-red-800');
            });

            document.getElementById('undo').addEventListener('click', undo);
            document.getElementById('redo').addEventListener('click', redo);

            function download(dataURL, filename) {
                const a = document.createElement('a');
                a.href = dataURL;
                a.download = filename;
                document.body.appendChild(a);
                a.click(); // Programmatic click
                document.body.removeChild(a);
            }

            exportDropdownButton.addEventListener('click', (e) => {
                e.preventDefault();
                if (!exportDropdownButton.disabled) {
                    exportDropdownMenu.classList.toggle('hidden');
                }
            });

            document.addEventListener('click', (e) => {
                if (!exportDropdownButton.contains(e.target) && !exportDropdownMenu.contains(e.target)) {
                    exportDropdownMenu.classList.add('hidden');
                }
            });
            
            /**
             * Utility function to export the signature with a white background.
             * This function is used for JPEG and Opaque PNG formats.
             */
            function exportOpaque(mimeType, filename, quality) {
                if (signaturePad.isEmpty()) return;
                
                // 1. Get the signature data (which is transparent)
                // We use image/png here to preserve the integrity of the data
                const signatureDataURL = signaturePad.toDataURL('image/png'); 

                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                const img = new Image();
                
                // Get the displayed (scaled) size for the temp canvas
                tempCanvas.width = canvas.width / RATIO;
                tempCanvas.height = canvas.height / RATIO;
                
                img.onload = () => {
                    try {
                        // 2. Fill the temporary canvas with white background
                        tempCtx.fillStyle = '#ffffff';
                        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                        // 3. Draw the transparent signature image on top
                        tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);

                        // 4. Export the final opaque image
                        const opaqueDataURL = tempCanvas.toDataURL(mimeType, quality);
                        download(opaqueDataURL, filename);
                        showTemporaryMessage(`${filename.split('.')[1].toUpperCase()} (White BG) downloaded successfully!`, 'bg-green-100 text-green-800');
                    } catch (error) {
                         console.error("Error during opaque export processing:", error);
                         showTemporaryMessage('Export failed due to image processing error.', 'bg-red-100 text-red-800');
                    }
                };

                img.onerror = () => {
                    console.error("Failed to load signature data for opaque export.");
                    showTemporaryMessage('Export failed: Could not process signature data.', 'bg-red-100 text-red-800');
                };

                img.src = signatureDataURL;
            }

            // Export Opaque PNG (uses the new utility)
            document.getElementById('exportPngOpaque').addEventListener('click', (e) => {
                e.preventDefault();
                exportDropdownMenu.classList.add('hidden');
                exportOpaque('image/png', 'signature_opaque.png', 1.0);
            });

            // Export Transparent PNG (now trivial, as the canvas is already transparent)
            document.getElementById('exportPngTransparent').addEventListener('click', (e) => {
                e.preventDefault();
                exportDropdownMenu.classList.add('hidden');
                if (signaturePad.isEmpty()) return;
                
                // The canvas is already transparent, so we just export the data directly!
                const dataURL = signaturePad.toDataURL('image/png'); 
                
                download(dataURL, 'signature_transparent.png');
                showTemporaryMessage('PNG (Transparent) downloaded successfully! Ready for use on any background.', 'bg-green-100 text-green-800');
            });

            // Export JPEG (uses the new utility)
            document.getElementById('exportJpeg').addEventListener('click', (e) => {
                e.preventDefault();
                exportDropdownMenu.classList.add('hidden');
                exportOpaque('image/jpeg', 'signature.jpeg', 0.8);
            });

            // Export SVG (Vector format)
            document.getElementById('exportSvg').addEventListener('click', (e) => {
                e.preventDefault();
                exportDropdownMenu.classList.add('hidden');
                if (signaturePad.isEmpty()) return;
                const svg = signaturePad.toSVG();
                const blob = new Blob([svg], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                download(url, 'signature.svg');
                showTemporaryMessage('SVG downloaded successfully!', 'bg-green-100 text-green-800');
            });

            // --- 6. Message Box Utility ---

            function showTemporaryMessage(message, classes = 'bg-green-100 text-green-800') {
                messageBox.textContent = message;
                messageBox.className = 'p-3 rounded-lg transition-opacity duration-300 ' + classes;
                messageBox.classList.remove('hidden', 'opacity-0');
                messageBox.classList.add('opacity-100');

                setTimeout(() => {
                    messageBox.classList.remove('opacity-100');
                    messageBox.classList.add('opacity-0');
                    setTimeout(() => {
                        messageBox.classList.add('hidden');
                    }, 300); 
                }, 3000);
            }

            // Start everything up
            initSignaturePad();
            updateButtons();
        });
    </script>
</body>
